"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Configurator: () => Configurator,
  ExplicitFunction: () => ExplicitFunction,
  FluentConfigurator: () => FluentConfigurator,
  Model: () => Model,
  MutationIdentity: () => MutationIdentity,
  and: () => and,
  api: () => api,
  arrayToKeyLookup: () => arrayToKeyLookup,
  arrayToObject: () => arrayToObject,
  condition: () => condition,
  createFnWithProps: () => createFnWithProps,
  createMutationFunction: () => createMutationFunction,
  defineProperties: () => defineProperties,
  defineType: () => defineType,
  dictToKv: () => dictToKv,
  dictionaryTransform: () => dictionaryTransform,
  entries: () => entries,
  equals: () => equals,
  filterDictArray: () => filterDictArray,
  fnWithProps: () => fnWithProps,
  greater: () => greater,
  groupBy: () => groupBy,
  idLiteral: () => idLiteral,
  idTypeGuard: () => idTypeGuard,
  identity: () => identity,
  ifTypeOf: () => ifTypeOf,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isFalse: () => isFalse,
  isFunction: () => isFunction,
  isNull: () => isNull,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTrue: () => isTrue,
  isType: () => isType,
  isUndefined: () => isUndefined,
  keys: () => keys,
  kindLiteral: () => kindLiteral,
  kv: () => kv,
  kvToDict: () => kvToDict,
  less: () => less,
  literal: () => literal,
  mapValues: () => mapValues,
  nameLiteral: () => nameLiteral,
  or: () => or,
  randomString: () => randomString,
  readonlyFnWithProps: () => readonlyFnWithProps,
  ruleSet: () => ruleSet,
  strArrayToDict: () => strArrayToDict,
  type: () => type,
  typeApi: () => typeApi,
  uuid: () => uuid,
  valueTypes: () => valueTypes,
  withValue: () => withValue
});
module.exports = __toCommonJS(src_exports);

// src/Mutation/MutationFunction.ts
function createMutationFunction(state) {
  return (mutationIdentity) => {
    return mutationIdentity(state);
  };
}

// src/Mutation/MutationIdentity.ts
function MutationIdentity() {
  return function(m) {
    return m;
  };
}

// src/shared/randomString.ts
function randomString() {
  return Math.trunc((1 + Math.random()) * 65536).toString(16).slice(1);
}

// src/shared/uuid.ts
function uuid() {
  return `${randomString()}${randomString()}-${randomString()}-${randomString()}-${randomString()}-${randomString()}-${randomString()}${randomString()}${randomString()}`;
}

// src/shared/valueTypes.ts
var valueTypes = {
  string: ["", false],
  boolean: [true, false],
  number: [0, false],
  function: [() => "", false],
  object: [{}, false],
  array: (arr = []) => [arr, false],
  null: [null, false],
  symbol: [Symbol("type"), false],
  undefined: [void 0, false],
  true: [true, true],
  false: [false, true],
  literal: (v) => {
    return [v, true];
  },
  literalArray: (arr) => [arr, true]
};

// src/utility/keys.ts
function keys(obj, ...without) {
  const v = without.length > 0 ? Object.keys(obj).filter((k) => !without.includes(k)) : Object.keys(obj);
  return v;
}

// src/utility/createFnWithProps.ts
function createFnWithProps(fn, props) {
  return (() => {
    let combined = fn;
    for (const prop of keys(props)) {
      combined[prop] = props[prop];
    }
    return combined;
  })();
}
function fnWithProps(fn, props) {
  let combined = fn;
  for (const prop of keys(props)) {
    combined[prop] = props[prop];
  }
  return combined;
}
function readonlyFnWithProps(fn, props) {
  let combined = fn;
  for (const prop of keys(props)) {
    combined[prop] = props[prop];
  }
  return combined;
}

// src/utility/ruleset.ts
function ruleSet(defn) {
  return defn;
}

// src/utility/api/api.ts
var api = (priv) => (pub) => {
  const surface = () => pub;
  surface.prototype.priv = () => priv;
  return surface;
};

// src/utility/dictionary/arrayToKeyLookup.ts
function arrayToKeyLookup(...keys2) {
  const obj = {};
  for (const key of keys2) {
    obj[key] = true;
  }
  return obj;
}

// src/utility/dictionary/defineProperties.ts
function defineProperties(obj) {
  return {
    ro(prop, errorMsg) {
      Object.defineProperty(obj, prop, {
        writable: false,
        set(v) {
          const message = errorMsg ? errorMsg(prop, v) : `The ${String(
            prop
          )} is readonly but an attempt was made to change it's value to "${JSON.stringify(
            v
          )}"!`;
          throw new Error(message);
        }
      });
      return obj;
    }
  };
}

// src/utility/dictionary/dictionaryTransform.ts
function dictionaryTransform(input, transform) {
  return keys(input).reduce((acc, i) => {
    const key = i;
    return { ...acc, [key]: transform(input, key) };
  }, {});
}

// src/utility/dictionary/entries.ts
function entries(obj) {
  const iterable = {
    *[Symbol.iterator]() {
      for (const k of keys(obj)) {
        yield [k, obj[k]];
      }
    }
  };
  return iterable;
}

// src/utility/dictionary/mapValues.ts
function mapValues(obj, valueMapper) {
  return Object.fromEntries(
    [...entries(obj)].map(([k, v]) => [k, valueMapper(v)])
  );
}

// src/utility/dictionary/strArrayToDict.ts
function strArrayToDict(...strings) {
  return strings.reduce((acc, str) => {
    acc = { ...acc, [str]: true };
    return acc;
  }, {});
}

// src/utility/dictionary/kv/dictToKv.ts
function dictToKv(obj, _makeTuple = false) {
  return keys(obj).map((k) => {
    return { key: k, value: obj[k] };
  });
}

// src/utility/state/Configurator.ts
function omit(obj, ...removals) {
  const untyped = removals;
  return Object.fromEntries(Object.entries(obj).filter(([key]) => !untyped.includes(key)));
}
function Configurator() {
  let configuration = () => ({});
  const api2 = () => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const config = configuration();
        const updated = { ...config, ...keyValue };
        configuration = () => updated;
        return updated;
      },
      remove(key) {
        const config = configuration();
        const updated = omit(config, key);
        configuration = () => updated;
        return updated;
      },
      done() {
        return configuration();
      }
    };
  };
  return api2();
}

// src/utility/state/FluentConfigurator.ts
function FluentConfigurator(initial = {}) {
  const api2 = (current) => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const updated = { ...keyValue, ...current };
        return api2(updated);
      },
      done() {
        return current;
      }
    };
  };
  if (initial && typeof initial !== "object") {
    throw new Error(
      "The FluentConfigurator was passed a non-object based value as the initial value. This is not allowed."
    );
  }
  return initial ? api2(initial) : api2({});
}

// src/utility/dictionary/kv/filterDictArray.ts
function filterDictArray(dictArr, cb) {
  const state = Configurator();
  const updated = dictArr.filter((i) => {
    const [k, v] = i;
    const keep = cb(k, v);
    if (!keep) {
      state.set(k, true);
    }
    return keep;
  });
  return updated;
}

// src/utility/dictionary/kv/kv.ts
function kv(key, value) {
  return { [key]: value };
}

// src/utility/dictionary/kv/kvToDict.ts
function kvToDict(kvArr) {
  const out = {};
  for (const kv2 of kvArr) {
    out[kv2.key] = kv2.value;
  }
  return out;
}

// src/utility/lists/groupBy.ts
function groupBy(_data) {
  throw new Error("not implemented");
}

// src/utility/literals/ExplicitFunction.ts
function ExplicitFunction(fn) {
  return fn;
}

// src/utility/literals/arrayToObject.ts
function arrayToObject(prop, unique) {
  const transform = (arr) => {
    const result = unique !== false ? arr.reduce((acc, v) => ({ ...acc, [v[prop]]: v }), {}) : arr.reduce((acc, v) => {
      const existing = acc[v[prop]] || [];
      return { ...acc, [v[prop]]: [...existing, v] };
    }, {});
    return result;
  };
  return transform;
}

// src/utility/literals/defineType.ts
function defineType(literal2 = {}) {
  return (wide = {}) => {
    return literal2 ? { ...wide, ...literal2 } : wide;
  };
}

// src/utility/literals/identity.ts
var identity = (v) => v;

// src/utility/literals/literal.ts
function idLiteral(o) {
  return { ...o, id: o.id };
}
function nameLiteral(o) {
  return o;
}
function kindLiteral(o) {
  return o;
}
function idTypeGuard(_o) {
  return true;
}
function literal(obj) {
  return obj;
}

// src/utility/map-reduce/filter.ts
var equals = (field, val) => ({
  kind: "Equals",
  field,
  val
});
var greater = (field, val) => ({
  kind: "Greater",
  field,
  val
});
var less = (field, val) => ({
  kind: "Less",
  field,
  val
});
var and = (a, b) => ({
  kind: "And",
  a,
  b
});
var or = (a, b) => ({
  kind: "Or",
  a,
  b
});

// src/utility/modelling/Model.ts
function Model(name) {
  return {
    required(_prop) {
      return Model(name);
    },
    optional(_prop) {
      return Model(name);
    },
    done() {
      return {
        __model__: name,
        __kind__: "model"
      };
    }
  };
}

// src/utility/runtime/condition.ts
var condition = (c, input) => {
  return c(input);
};

// src/utility/runtime/ifTypeOf.ts
function runtimeExtendsCheck(val, base, narrow = false) {
  if (typeof val !== typeof base) {
    return false;
  }
  switch (typeof val) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "bigint":
      return narrow ? val === base : true;
    case "undefined":
      return true;
    case "function":
      if (narrow) {
        throw new Error(`Use of narrowlyExtends with a function is not possible!`);
      }
      return true;
    case "object":
      if (val === null && base === null) {
        return true;
      } else {
        return keys(base).every(
          (i) => runtimeExtendsCheck(val[i], base[i], narrow)
        );
      }
  }
}
var ifTypeOf = (val) => ({
  extends: (base) => {
    const valid = runtimeExtendsCheck(val, base, false);
    const trueFalse = valid ? true : false;
    return {
      then: (then) => ({
        else: (elseVal) => {
          return valid ? typeof then === "undefined" ? val : then : elseVal;
        }
      }),
      else: (elseVal) => valid ? val : elseVal
    } && trueFalse;
  },
  narrowlyExtends: (base) => {
    const valid = runtimeExtendsCheck(val, base, true);
    const trueFalse = valid ? true : false;
    return {
      then: (then) => ({
        else: (elseVal) => {
          return valid ? typeof then === "undefined" ? val : then : elseVal;
        }
      }),
      else: (elseVal) => valid ? val : elseVal
    } && trueFalse;
  }
});

// src/utility/runtime/conditions/isArray.ts
function isArray(i) {
  return Array.isArray(i) === true;
}

// src/utility/runtime/conditions/isBoolean.ts
function isBoolean(i) {
  return typeof i === "boolean";
}

// src/utility/runtime/conditions/isFalse.ts
function isFalse(i) {
  return typeof i === "boolean" && !i;
}

// src/utility/runtime/conditions/isFunction.ts
function isFunction(input) {
  return typeof input === "function";
}

// src/utility/runtime/conditions/isNull.ts
function isNull(i) {
  return i === null;
}

// src/utility/runtime/conditions/isNumber.ts
function isNumber(i) {
  return typeof i === "number";
}

// src/utility/runtime/conditions/isObject.ts
function isObject(i) {
  return typeof i === "object" && i !== null && Array.isArray(i) === false;
}

// src/utility/runtime/conditions/isString.ts
function isString(i) {
  return typeof i === "string";
}

// src/utility/runtime/conditions/isSymbol.ts
function isSymbol(i) {
  return typeof i === "symbol";
}

// src/utility/runtime/conditions/isTrue.ts
function isTrue(i) {
  return typeof i === "boolean" && i;
}

// src/utility/runtime/conditions/isUndefined.ts
function isUndefined(i) {
  return typeof i === "undefined";
}

// src/utility/runtime/type.ts
var typeApi = () => ({
  string: {
    name: "string",
    type: "",
    typeGuard: (v) => isString(v),
    is: isString
  },
  boolean: {
    name: "boolean",
    type: true,
    typeGuard: (v) => isBoolean(v),
    is: isBoolean
  },
  number: {
    name: "number",
    type: 1,
    typeGuard: (v) => isNumber(v),
    is: isNumber
  },
  function: {
    name: "function",
    type: Function,
    typeGuard: (v) => isFunction(v),
    is: isFunction
  },
  null: {
    name: "null",
    type: null,
    typeGuard: (v) => isNull(v),
    is: isNull
  },
  symbol: {
    name: "symbol",
    type: Symbol(),
    typeGuard: (v) => isSymbol(v),
    is: isSymbol
  },
  undefined: {
    name: "undefined",
    type: void 0,
    typeGuard: (v) => isUndefined(v),
    is: isUndefined
  },
  true: {
    name: "true",
    type: true,
    typeGuard: (v) => isTrue(v),
    is: isTrue
  },
  false: {
    name: "false",
    type: false,
    typeGuard: (v) => isFalse(v),
    is: isFalse
  },
  object: {
    name: "object",
    type: {},
    typeGuard: (v) => isObject(v),
    is: isObject
  },
  array: {
    name: "array",
    type: {},
    typeGuard: (v) => isArray(v),
    is: isObject
  }
});
function isType(t) {
  return typeof t === "object" && ["name", "type", "is"].every((i) => Object.keys(t).includes(i));
}
function type(fn) {
  const result = fn(typeApi());
  if (!isType(result)) {
    throw new Error(
      `When using type(), the callback passed in returned an invalid type! Value returned was: ${result}`
    );
  }
  return result;
}

// src/utility/runtime/withValue.ts
function withValue(td) {
  return (obj) => {
    const t = type(td);
    return Object.fromEntries(
      [...entries(obj)].filter(([_key, value]) => {
        return t.typeGuard(value);
      })
    );
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Configurator,
  ExplicitFunction,
  FluentConfigurator,
  Model,
  MutationIdentity,
  and,
  api,
  arrayToKeyLookup,
  arrayToObject,
  condition,
  createFnWithProps,
  createMutationFunction,
  defineProperties,
  defineType,
  dictToKv,
  dictionaryTransform,
  entries,
  equals,
  filterDictArray,
  fnWithProps,
  greater,
  groupBy,
  idLiteral,
  idTypeGuard,
  identity,
  ifTypeOf,
  isArray,
  isBoolean,
  isFalse,
  isFunction,
  isNull,
  isNumber,
  isObject,
  isString,
  isSymbol,
  isTrue,
  isType,
  isUndefined,
  keys,
  kindLiteral,
  kv,
  kvToDict,
  less,
  literal,
  mapValues,
  nameLiteral,
  or,
  randomString,
  readonlyFnWithProps,
  ruleSet,
  strArrayToDict,
  type,
  typeApi,
  uuid,
  valueTypes,
  withValue
});
