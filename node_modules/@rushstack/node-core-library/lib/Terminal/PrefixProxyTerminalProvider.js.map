{"version":3,"file":"PrefixProxyTerminalProvider.js","sourceRoot":"","sources":["../../src/Terminal/PrefixProxyTerminalProvider.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,kCAA+B;AAmB/B;;;;;GAKG;AACH,MAAa,2BAA2B;IAMtC,YAAmB,OAA4C;QAC7D,MAAM,EAAE,gBAAgB,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAC7C,IAAI,CAAC,uBAAuB,GAAG,gBAAgB,CAAC;QAChD,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC;QAC7B,gEAAgE;QAChE,IAAI,CAAC,aAAa,GAAG,IAAI,MAAM,CAAC,GAAG,WAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,YAAY,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAClG,CAAC;IAED,gBAAgB;IAChB,IAAW,aAAa;QACtB,OAAO,IAAI,CAAC,uBAAuB,CAAC,aAAa,CAAC;IACpD,CAAC;IAED,gBAAgB;IAChB,IAAW,YAAY;QACrB,OAAO,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC;IACnD,CAAC;IAED,gBAAgB;IACT,KAAK,CAAC,IAAY,EAAE,QAAkC;QAC3D,4EAA4E;QAC5E,IAAI,YAAY,GAAW,CAAC,CAAC;QAC7B,kDAAkD;QAClD,IAAI,YAAoC,CAAC;QACzC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;YACrD,sEAAsE;YACtE,MAAM,YAAY,GAAW,YAAY,CAAC,KAAK,CAAC;YAChD,MAAM,QAAQ,GAAW,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;YAC/D,MAAM,WAAW,GAAW,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,QAAQ,CAAC,EAAE,CAAC;YAC9F,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YAC1D,8EAA8E;YAC9E,YAAY,GAAG,QAAQ,CAAC;YACxB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC;SACpC;QAED,sGAAsG;QACtG,MAAM,aAAa,GAAW,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QAC3D,IAAI,aAAa,CAAC,MAAM,EAAE;YACxB,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,aAAa,EAAE,EAAE,QAAQ,CAAC,CAAC;YACvF,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SAC1B;IACH,CAAC;CACF;AAjDD,kEAiDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { ITerminalProvider, TerminalProviderSeverity } from './ITerminalProvider';\nimport { Text } from '../Text';\n\n/**\n * Options for {@link PrefixProxyTerminalProvider}.\n *\n * @beta\n */\nexport interface IPrefixProxyTerminalProviderOptions {\n  /**\n   * The {@link ITerminalProvider} that will be wrapped.\n   */\n  terminalProvider: ITerminalProvider;\n\n  /**\n   * The prefix that should be added to each line of output.\n   */\n  prefix: string;\n}\n\n/**\n * Wraps an existing {@link ITerminalProvider} that prefixes each line of output with a specified\n * prefix string.\n *\n * @beta\n */\nexport class PrefixProxyTerminalProvider implements ITerminalProvider {\n  private _parentTerminalProvider: ITerminalProvider;\n  private _prefix: string;\n  private _currentPrefix: string;\n  private _newlineRegex: RegExp;\n\n  public constructor(options: IPrefixProxyTerminalProviderOptions) {\n    const { terminalProvider, prefix } = options;\n    this._parentTerminalProvider = terminalProvider;\n    this._prefix = prefix;\n    this._currentPrefix = prefix;\n    // eslint-disable-next-line @rushstack/security/no-unsafe-regexp\n    this._newlineRegex = new RegExp(`${Text.escapeRegExp(terminalProvider.eolCharacter)}|\\\\n`, 'g');\n  }\n\n  /** @override */\n  public get supportsColor(): boolean {\n    return this._parentTerminalProvider.supportsColor;\n  }\n\n  /** @override */\n  public get eolCharacter(): string {\n    return this._parentTerminalProvider.eolCharacter;\n  }\n\n  /** @override */\n  public write(data: string, severity: TerminalProviderSeverity): void {\n    // We need to track newlines to ensure that the prefix is added to each line\n    let currentIndex: number = 0;\n    // eslint-disable-next-line @rushstack/no-new-null\n    let newlineMatch: RegExpExecArray | null;\n    while ((newlineMatch = this._newlineRegex.exec(data))) {\n      // Extract the line, add the prefix, and write it out with the newline\n      const newlineIndex: number = newlineMatch.index;\n      const newIndex: number = newlineIndex + newlineMatch[0].length;\n      const dataToWrite: string = `${this._currentPrefix}${data.substring(currentIndex, newIndex)}`;\n      this._parentTerminalProvider.write(dataToWrite, severity);\n      // Update the currentIndex to start the search from the char after the newline\n      currentIndex = newIndex;\n      this._currentPrefix = this._prefix;\n    }\n\n    // The remaining data is not postfixed by a newline, so write out the data and set _isNewline to false\n    const remainingData: string = data.substring(currentIndex);\n    if (remainingData.length) {\n      this._parentTerminalProvider.write(`${this._currentPrefix}${remainingData}`, severity);\n      this._currentPrefix = '';\n    }\n  }\n}\n"]}