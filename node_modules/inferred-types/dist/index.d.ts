/**
 * **MutationIdentity**
 *
 * Defines a function which is passed a state `T` and returns a function with
 * an arbitrary -- but strongly typed -- set of parameters `P` which _must_ return
 * the same state `T` back.
 *
 * This allows `T` to be mutated by a relatively unconstrained set of mutation functions with the
 * sole guarentee that the form `T` is preserved.
 */
declare type MutationIdentity<T, P extends any[]> = (state: T) => (...args: P) => T;
/**
 * **MutationIdentity**
 *
 * A function which strongly types the construction of a `MutationIdentity`
 * higher-order function to be built. Usage:
 *
 * - The structure of the _state_ is defined in the first call as `T`
 * - The interior function than defines a mutation function which implicitly
 * defines the calling signature as `P` but is required to return the identity state
 * structure `T`.
 *
 * ```ts
 * type State = { foo: number, bar: number };
 * const incr = MutationIdentity<State>()(
 *    s => () => {...s, foo: s.foo++}
 * );
 * ```
 */
declare function MutationIdentity<T>(): <M extends MutationIdentity<T, P>, P extends any[]>(m: M) => M;

declare type MutationFunction<T extends any, P extends any[]> = (...args: P) => T;
/**
 * **MutationFunction**
 *
 * Given a `MutationIdentity` higher-order function to work with, _this_ higher order expression
 * allows you to specify the structure of "state" `T` with the first function call; the
 * remaining function then serves as a strongly typed way to do partial application and get
 * back just the _mutation function_ responsible for changing the state. The mutation function
 * will take the form of:
 *
 * ```ts
 * const fn: (...args: P) => T = MutationFunction<T>()(mutationIdentity);
 * ```
 */
declare function createMutationFunction<T extends any>(state: T): <M extends MutationIdentity<T, P>, P extends any[]>(mutationIdentity: M) => (...args: P) => T;

declare function randomString(): string;

declare function uuid(): string;

/**
 * A union of types used in conjunction with the `literalValues()` function
 * to produce a _narrow_ type definition of a passed in dictionary object.
 */
declare type Narrowable = string | number | boolean | symbol | object | undefined | void | null | {};

declare type ValueTuple = [type: any, narrowable: boolean];
/**
 * An API surface for choosing a **type** which is defined for run-time
 * use but is translatable to the type system as well.
 */
declare type ValueTypes = {
    string: [string, false];
    boolean: [];
};
declare const valueTypes: {
    string: [string, false];
    boolean: [boolean, false];
    number: [number, false];
    function: [Function, false];
    object: [Record<string, any>, false];
    array: <T extends unknown>(arr?: T[]) => [T[], false];
    null: [null, false];
    symbol: [Symbol, false];
    undefined: [undefined, false];
    true: [true, true];
    false: [false, true];
    /** pass in a literal type */
    literal: <N extends Narrowable, T_1 extends string | number | boolean | symbol | Record<any, N> | null | undefined>(v: T_1) => [T_1, true];
    literalArray: <N_1 extends Narrowable, T_2 extends string | number | boolean | symbol | Record<any, N_1> | null | undefined>(arr: T_2[]) => (boolean | T_2[])[];
};
declare type ValueTypeFunc<N extends Narrowable, T extends Record<any, N> | number | string | boolean | symbol | null | Function> = (v: ValueTypes) => [T, boolean];

declare type ApiFunction<P extends any[], R extends any> = (...args: P) => R;
declare type FluentFunction<P extends any[], R extends any> = (...args: P) => R;
declare type ApiValue<V extends any> = V;
/**
 * Expresses the API in a structured manner while making distinction
 * between a function endpoint and a _fluent_ function endpoint.
 */
declare type Api<T extends object> = {
    [K in keyof T]: T[K] extends (...args: any) => T ? FluentFunction<Parameters<T[K]>, ReturnType<T[K]>> : T[K] extends (...args: any) => any ? ApiFunction<Parameters<T[K]>, ReturnType<T[K]>> : ApiValue<T[K]>;
};

/**
 * Define a class constructor; allowing strong typing for constructor's parameters
 * and the returned class structure.
 */
declare type Constructor<Ctor extends any[], Klass extends any> = new (...props: Ctor) => Klass;

/**
 * Provides the values of an Typescript **enum**:
 * ```ts
 * enum Foo { foo, bar, baz };
 * // "0" | "1" | "2"
 * type NumerericEnum = EnumValues<Foo>;
 * enum Bar { foo = "foey", bar = "barred" };
 * // "foey" | "barred"
 * type StringEnum = EnumValues<Bar>;
 * ```
 *
 * **Note:** combine with `Numeric` to get number based indexes
 */
declare type EnumValues<T extends string | number> = `${T}`;

/**
 * Recursively goes over an object based structure and tries to reduce
 * it down to just a simple key/value type.
 */
declare type ExpandRecursively<T> = T extends object ? T extends (...args: any[]) => any ? T : {
    [K in keyof T]: ExpandRecursively<T[K]>;
} : T;

/**
 * Returns the first values type in an array of values
 */
declare type First<T extends any[]> = T[0] extends T[number] ? T[0] : never;

/**
 * Defines a function type.
 *
 * - without the generic `T` specified it simply matches correctly on both plain functions as well as functions which also have properties on them (this is consistent to how runtime's `typeof` operator works)
 * - with the generic you can specify the shape of the key/values
 */
declare type FunctionType<T extends {} = {}> = {} extends T ? Function | (Function & {
    [key: string]: any;
}) : Function | (Function & T);

/**
 * Provides a unary condition for the type system:
 * ```ts
 * // "a"
 * type T = If<true, "a", "b'>;
 * // "b"
 * type F = If<false, "a", "b">;
 * ```
 */
declare type If<C extends boolean, T, F> = C extends T ? C | F : never;

/**
 * **Include<T, U, L>**
 *
 * _Allows_ any value `T` which extends `U` otherwise sets type to `never`. Normally, you'll just ignore
 * the `L` generic but if need the comparison to be literal you can set to `true`:
 *
 * ```ts
 * const foo: "foo" = "foo";
 * // "foo"
 * type Normal = Include<typeof foo, string>;
 * // L1 is never, L2 is "foo"
 * type L1 = Include<typeof foo, string, true>;
 * type L2 = Include<typeof foo, "foo", true>;
 * ```
 */
declare type Include<T, U, L extends boolean = false> = L extends true ? T extends U ? U extends T ? T : never : never : T extends U ? T : never;

/**
 * A type takes the two arguments. The first is an array of string values, the second is the value
 * which is being tested as it whether or not it's _included_ in the array. Result is true or false.
 */
declare type Includes<T extends readonly any[], U> = U extends T[number] ? true : false;

/**
 * A "KeyedRecord" is intended to store a value without
 * losing any ability to infer type information later.
 *
 * The structure is always represented as a two-key
 * dictionary, where one key is always `__key` and the value
 * of this key points to the second key.
 *
 * For example:
 * ```ts
 * const song: KeyedRecord = { __key: "song", song: XXX }
 * ```
 */
declare type KeyedRecord<K extends string, V extends any, T extends {
    __key: K;
} = {
    __key: K;
}, U extends keyof T = keyof T & K> = {
    [X in U]: T[X];
} & {
    K: V;
};

/**
 * A Utility class that provides the same functionality as the built-in
 * `keyof` TS operator but can also:
 *
 * - receive an array of strings and convert that into a union type.
 * - you can exclude literal string from the returned result
 *
 * ```ts
 * const t1 = { foo: 1, bar: 2 };
 * // "foo" | "bar"
 * type K = Keys<typeof t1>;
 * const t2 = ["foo", "bar"] as const;
 * // "foo" | "bar"
 * type K = Keys<typeof t2>;
 * ```
 */
declare type Keys<T extends Record<string, any> | readonly string[], W extends string | undefined = undefined> = T extends readonly string[] ? W extends string ? Exclude<T[number], W> : T[number] : W extends string ? Exclude<keyof T & string, W> : keyof T & string;

/**
 * Utility type which returns the length of an array literal
 *
 * ```ts
 * type Three = Length<[ "a", "b", "c" ]>;
 * ```
 */
declare type Length<T extends readonly any[]> = T["length"];

/**
 * Makes a readonly structure mutable
 */
declare type Mutable<T> = {
    -readonly [K in keyof T]: T[K];
};

/**
 * Provides a negation of a type of the type `T` _not_ `U`.
 * ```ts
 * const foo = 42;
 * // 33
 * type NotTheMeaningOfLife = Not<33, 42>;
 * // never
 * type NotTheMeaningOfLife = Not<42, 42>;
 * ```
 *
 * Note: same as `Exclude`
 */
declare type Not<T, U> = T extends U ? never : T;

declare type Digital = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
declare type MakeArray<S extends string, T extends any[] = []> = S extends `${T["length"]}` ? T : MakeArray<S, [...T, 0]>;
declare type Multiply10<T extends any[]> = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T];
/**
 * Converts a string literal to a numeric literal
 * ```ts
 * // 0
 * type Zero = Numeric<"0">;
 * // 10
 * type Ten = Numeric<"10">;
 * ```
 */
declare type Numeric<S extends string, T extends any[] = []> = S extends `${infer S1}${infer S2}` ? S1 extends Digital ? Numeric<S2, [...Multiply10<T>, ...MakeArray<S1>]> : never : T["length"];

/**
 * **Opaque**
 *
 * Create an opaque type, which hides its internal details from the public, and
 * can only be created by being used explicitly.
 *
 * Note: taken from [type-fest](https://github.com/sindresorhus/type-fest/blob/main/source/opaque.d.ts)
 * repo.
 */
declare type Opaque<Type, Token = unknown> = Type & {
    readonly __opaque__: Token;
};

/**
 * **Retain<T, K>**
 *
 * Reduces the type system to just the key/values which are represented in `K`.
 * The `L` generic can largely be ignored unless you need _literal_ equality.
 *
 * ```ts
 * type Obj = { foo: 1, bar: number, baz: string };
 * // { foo: 1, bar: number }
 * type Retained = Retain<Obj, "foo" | "bar">;
 * ```
 *
 * **Note:** in essence this is the _opposite_ of `Exclude<T,K>`
 */
declare type Retain<T, K extends keyof T> = Pick<T, Include<keyof T, K>>;

/**
 * UnionToIntersection<{ foo: string } | { bar: string }> =
 *  { foo: string } & { bar: string }.
 */
declare type UnionToIntersection<U> = (U extends unknown ? (arg: U) => 0 : never) extends (arg: infer I) => 0 ? I : never;

/**
 * Often when mutating the shape of an object you will end up with the union of a number of
 * `Record<string, x>` and `Record<string, y>` which is messy to look at and take away meaning.
 *
 * This type utility will cleanup an object and return a simple dictionary definition for it.
 */
declare type SimplifyObject<T extends {}> = ExpandRecursively<UnionToIntersection<ExpandRecursively<T>>>;

/**
 * **SameKeys**
 *
 * Creates a _type_ with the same _keys_ as `T` but sets all values of these keys to `A` (which is
 * **any** by default).
 *
 * Note: meant to be used as part of an _extends_ clause in most cases.
 */
declare type SameKeys<T extends object, A extends any = any> = {
    [P in keyof T]: A;
};

/**
 * **Transformer**
 *
 * A function responsible for transforming the _values_ of
 * dictionary `I` into different _values_ for dictionary `O`.
 *
 * This type utility assumes that _keys_ of both dictionaries
 * are the same.
 */
declare type Transformer<I extends object, O extends SameKeys<I>, K extends keyof I = keyof I> = (input: I, key: K) => O[K];

/**
 * **TypeGuard**
 *
 * a typing for a **TS** type-guard which evaluates an _unknown_ input
 * and determines if it is of type `T`.
 */
declare type TypeGuard<T> = (thing: unknown) => thing is T;

/**
 * Allows filtering down `T` to those which extend a given type `U`.
 *
 * - `T` is either a dictionary (where keys will be used to compare) or
 * a readonly sting array.
 * ```ts
 * const arr = ["foo", "bar", "baz"];
 * // "bar" | "baz"
 * type BA = Where<typeof arr, `ba${string}`>;
 * ```
 */
declare type Where<T extends Record<string, any> | readonly string[], U> = T extends readonly string[] ? Include<T[number], U> : {
    [K in keyof T]: K extends U ? K : never;
}[keyof T];
/**
 * Allows filtering down `T` to those which extend a given type `U`.
 *
 * - `T` is either a dictionary (where keys will be used to compare) or
 * a readonly sting array.
 * ```ts
 * const arr = ["foo", "bar", "baz"];
 * // "foo"
 * type F = WhereNot<typeof arr, `ba${string}`>;
 * ```
 */
declare type WhereNot<T extends Record<string, any> | readonly string[], U> = T extends readonly string[] ? Exclude<T[number], U> : {
    [K in keyof T]: K extends U ? never : K;
}[keyof T];

declare type AppendToObject<T, U extends keyof any, V> = {
    [K in keyof T | U]: K extends keyof T ? T[K] : V;
};
/**
 * Appends a new Key/Value to an existing dictionary <T>
 */
declare type AppendToDictionary<TDict, TKey extends string, TValue> = {
    [K in keyof TDict | TKey]: K extends keyof TDict ? TDict[K] : TValue;
};

/**
 * Accepts the `true` literal or _undefined_.
 */
declare type MaybeTrue = true | undefined;
/**
 * Accepts the `false` literal or _undefined_.
 */
declare type MaybeFalse = false | undefined;

declare type Condition<TInput extends Narrowable, TResult extends boolean> = (input: TInput) => TResult;
declare const condition: <TInput extends Narrowable, C extends Condition<Narrowable, boolean>>(c: C, input: TInput) => boolean;

/**
 * A conditional clause used in the application of the `ifTypeOf` utility
 */
declare type ExtendsClause<N extends Narrowable, TValue extends Record<keyof TValue, N> | number | string | boolean | symbol> = <TBase extends any>(base: TBase) => TValue extends TBase ? true : false;
/**
 * A conditional clause used in the application of the `ifTypeOf` utility
 */
declare type ExtendsNarrowlyClause<N extends Narrowable, TValue extends Record<keyof TValue, N> | number | string | boolean | symbol> = <NB extends Narrowable, TBase extends Record<keyof TBase, NB> | number | string | boolean | symbol>(base: TBase) => TValue extends TBase ? true : false;
/**
 * **TypeCondition**
 *
 * A partially applied type from the `ifTypeOf` utility where the base type has been
 * defined and we now need to express the type which is intended to extend it.
 *
 * - `extends` - compares with _wide_ types
 * - `narrowlyExtends` - compares with _narrow_ / _literal_ types
 */
declare type TypeCondition<N extends Narrowable, TValue extends Record<keyof TValue, N> | number | string | boolean | symbol> = {
    extends: ExtendsClause<N, TValue>;
    narrowlyExtends: ExtendsNarrowlyClause<N, TValue>;
};
declare const ifTypeOf: <N extends Narrowable, TValue extends string | number | boolean | symbol | Record<keyof TValue, N>>(val: TValue) => TypeCondition<N, TValue>;

declare type IsArray<T> = T extends any[] ? true : false;
declare function isArray<T>(i: T): IsArray<T>;

declare type IsBoolean<T> = T extends boolean ? true : false;
/**
 * Runtime and type checks whether a variable is a boolean value.
 */
declare function isBoolean<T extends any>(i: T): IsBoolean<T>;

declare type IsFalse<T extends Narrowable> = IsBoolean<T> extends true ? T extends false ? true : true extends T ? false : unknown : false;
declare function isFalse<T>(i: T): IsFalse<T>;

declare type IsFunction<T> = T extends FunctionType ? true : false;
/**
 * Checks whether a passed in value is a function and ensures run-time and types
 * are consistent.
 * ```ts
 * // true
 * const yup = isFunction(() => "hello world");
 * ```
 *
 * Note: the runtime `typeof [variable]` will correctly say "function" when a function is
 * encountered but if that function also has object types defined then the type will be a big
 * and ugly union type. This function will give you a proper boolean value in both cases.
 */
declare function isFunction<T extends unknown>(input: T): IsFunction<T>;

declare function isNull<T>(i: T): T extends null ? true : false;

declare function isNumber<T>(i: T): T extends number ? true : false;

declare type IsObject<T> = Mutable<T> extends Record<string, any> ? T extends FunctionType ? false : Mutable<T> extends any[] ? false : true : false;
declare type ObjectType = Not<Record<string, Narrowable>, FunctionType>;
/**
 * Detects whether the passed in `v` is of type "object" where an object
 * is defined to be a string keyed dictionary style object. This means that
 * arrays are excluded, as well as functions which also have properties hanging
 * off of them.
 */
declare function isObject<T extends unknown>(i: T): IsObject<T>;

declare type IsString<T> = T extends string ? true : false;
declare function isString<T>(i: T): IsString<T>;

declare function isSymbol<T>(i: T): T extends symbol ? true : false;

/**
 * Type utility which returns `true` or `false` based on
 * whether the type holds the narrow "true" type.
 * ```ts
 * // true
 * type T = IsTrue<true>;
 * // unknown
 * type U = IsTrue<boolean>;
 * // false
 * type F = IsTrue<false>;
 * type F2 = IsTrue<"false">;
 * ```
 */
declare type IsTrue<T> = IsBoolean<T> extends true ? T extends true ? true : T extends false ? false : unknown : false;
/**
 * Run-time and type checking of whether a variable is `true`.
 */
declare function isTrue<T extends Narrowable>(i: T): IsTrue<T>;

declare function isUndefined<T>(i: T): undefined extends T ? true : false;

declare type Type<T extends any, V extends Function> = {
    name: string;
    type: T;
    typeGuard: TypeGuard<T>;
    is: V;
};
declare const typeApi: () => {
    readonly string: Type<string, typeof isString>;
    readonly boolean: Type<boolean, typeof isBoolean>;
    readonly number: Type<number, typeof isNumber>;
    readonly function: Type<Function | (Function & {
        [key: string]: any;
    }), typeof isFunction>;
    readonly null: Type<null, typeof isNull>;
    readonly symbol: Type<symbol, typeof isSymbol>;
    readonly undefined: Type<undefined, typeof isUndefined>;
    readonly true: Type<true, typeof isTrue>;
    readonly false: Type<false, typeof isFalse>;
    readonly object: Type<Record<string, Narrowable>, typeof isObject>;
    readonly array: Type<any[], typeof isArray>;
};
declare type TypeApi = ReturnType<typeof typeApi>;
declare function isType<T extends any, V extends Function>(t: unknown): t is Type<T, V>;
declare type TypeDefinition<T extends any, V extends Function> = (defn: TypeApi) => Type<T, V>;
declare function type<T extends any, V extends Function>(fn: TypeDefinition<T, V>): Type<T, V>;

/**
 * Given a dictionary of key/values, where the value is a function, this
 * type utility will maintain the keys but change the values to whatever
 * the `ReturnType` of the function was.
 * ```ts
 * const api = {
 *    val: 42,
 *    hi: (name: string) => `hi ${name}`,
 *    bye: (name: string) => `bye ${name}`
 * };
 * // { hi: string; bye: string }
 * type Test = UnwrapValue<typeof api>
 * // { val: number; foo: string; bar: string }
 * type Test2 = UnwrapValue<typeof api, false>
 * ```
 */
declare type DictPartialApplication<T extends Record<string, any>, I extends boolean = true> = SimplifyObject<{
    [K in keyof T]: T[K] extends (...args: any[]) => any ? Record<K, ReturnType<T[K]>> : true extends I ? never : Record<K, T[K]>;
}[keyof T]>;

/**
 * Allow a dictionary have it's value's type changed to `T` while maintaining the keys in
 * the original object `I` so long as the original value for the KV pair extends `V`.
 *
 * If `V` is not specified then it defaults to _any_ and therefore all KVs are preserved.
 *
 * ```ts
 * type Obj = { foo: "hello", bar: 42, baz: () => "world" };
 * // { foo: number, bar: number, baz: number };
 * type AllNumbers = DictChangeValue<Obj, number>;
 * // { foo: number }
 * type StringToBool = DictChangeValue<Obj, boolean, string>
 * ```
 */
declare type DictChangeValue<
/** the object who's value-type we're changing */
I extends Record<string, any>, 
/** the return type that functions should be modified to have */
T extends any, 
/**
 *The type we expect in the value; if the value extends type `V` then the value will
 * be converted to type `O`; if not then the KV pair will be discarded
 */
V extends any = any> = SimplifyObject<{
    [K in keyof I]: I[K] extends V ? Record<K, T> : never;
}[keyof I]>;

/**
 * **DictPrependWithFn**
 *
 * Given a strongly typed object `<T>`, this utility will inject a function call with
 * arguments `<A>` and then return what had subsequently been the value of the property.
 *
 * Should you only want to apply this treatment to _some_ of the properties you can
 * pass in a value `<E>` which will ensure that only properties which _extend_ `E` will be
 * modified.
 */
declare type DictPrependWithFn<T extends Record<string, any>, A extends any[], E extends any = any> = SimplifyObject<{
    [K in keyof T]: T[K] extends E ? Record<K, (...args: A) => T[K]> : Record<K, T[K]>;
}[keyof T]>;

/**
 * **DictReturnValues**
 *
 * A type utility which receives an object `<T>` and then modifies
 * the return type of any properties which are a function to have this
 * new **ReturnType** `<R>`. Optionally you can specify a particular return type which
 * you are targeting and then
 */
declare type DictReturnValues<
/** the object which we expect to have props with function values */
T extends Record<string, any>, 
/** the return type that functions should be modified to have */
R extends any, 
/** optionally this utility can target only functions with a certain existing return value */
O extends (...args: any[]) => any = (...args: any[]) => any> = SimplifyObject<{
    [K in keyof T]: T[K] extends O ? T[K] extends (...args: infer A) => any ? Record<K, (...args: A) => R> : Record<K, T[K]> : Record<K, T[K]>;
}[keyof T]>;

/**
 * Get the type of a property of an object:
 * ```ts
 * const car = { make: "Chevy", model: "Malibu", }
 * ```
 */
declare type Get<T, K> = K extends `${infer FK}.${infer L}` ? FK extends keyof T ? Get<T[FK], L> : never : K extends keyof T ? T[K] : never;

/**
 * Maps from one type `I` to another `O`, where:
 *
 * - a **null** value indicates that there is no valid mapping for the given input
 * - you can either return a 1:1 or 1:M output as `O` or `O[]` when there is a mapping
 *
 * This type utility will ensure both `I` and `O` are honoured but if the runtime only
 * uses the type utility it's worth bearing in mind that while _typing_ will be as expected
 * the output parameter can assume properties that in fact do not reside
 *
 * ```ts
 * const mapper: ModelMapper<{title: string}, {title: string, kind: string}> = i => {
 *    title: i.title,
 *    kind: "markdown"
 * }
 * ```
 */
declare type MapTo<I extends {}, O extends {}> = (i: I) => O[];

/**
 * Given a dictionary of type `<T>`, this utility function will
 * make the `<M>` generic property _mutable_ and all other _read-only_.
 *
 * ```ts
 * // { foo: string, bar?: Readonly<number> }
 * type Example = MutableProps<{
 *    foo: Readonly<string>,
 *    bar?: number
 * }, "foo">;
 * ```
 */
declare type MutableProps<T extends {}, M extends keyof T & string> = ExpandRecursively<Mutable<Pick<T, M>> & Readonly<Pick<T, Keys<T, M>>>>;

/**
 * Given a dictionary of type `<T>`, this utility function will
 * make the `<R>` generic property _required_ (use a union to make
 * more than one prop required).
 *
 * ```ts
 * // { foo: string, bar?: number }
 * type Example = RequireProps<{foo?: string, bar?: number}, "foo">;
 * ```
 */
declare type RequireProps<T extends {}, R extends keyof T> = ExpandRecursively<Required<Pick<T, R>> & T>;

declare type LowerAlpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
/** Uppercase alphabetic character */
declare type UpperAlpha = Uppercase<LowerAlpha>;
/**
 * Alphabetical characters (upper and lower)
 */
declare type Alpha = UpperAlpha | LowerAlpha;
declare type Whitespace = " " | "\n" | "\t";
declare type Punctuation = "." | "," | ";" | "!" | "?";
/**
 * Characters which typically are used to separate words (but not including a space)
 */
declare type StringDelimiter = "_" | "-" | "/" | "\\";
declare type OpeningBracket = "(" | "[" | "{";
declare type ClosingBracket = ")" | "]" | "}";
/**
 * Opening and closing parenthesis
 */
declare type Parenthesis = "(" | ")";
/**
 * Opening and closing brackets
 */
declare type Bracket = OpeningBracket | ClosingBracket;
/**
 * Numeric string characters
 */
declare type NumericString = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
/**
 * Any alphabetic or numeric string character
 */
declare type AlphaNumeric = Alpha | NumericString;
declare type SpecialCharacters = "@" | "~" | "^" | "#" | "&" | "*";
/**
 * Non-alphabetic characters including whitespace, string numerals, and
 */
declare type NonAlpha = Whitespace | Punctuation | NumericString | Bracket | SpecialCharacters;

/**
 * Extracts the _required_ keys in the object's type
 */
declare type RequiredKeys<T extends object> = {
    [K in keyof T]-?: {} extends {
        [P in K]: T[K];
    } ? never : K;
}[keyof T];
/**
 * Extracts the _optional_ keys in the object's type
 */
declare type OptionalKeys<T extends object> = {
    [K in keyof T]-?: {} extends {
        [P in K]: T[K];
    } ? K : never;
}[keyof T];
/**
 * The _keys_ on a given object `T` which have a literal value of `W`.
 *
 * Optionally, you may provide a generic `E` to exclude certain keys in
 * result set.
 * ```ts
 * // "foo"
 * type Str = KeysWithValue<{ foo: "hi"; bar: 5 }>;
 * ```
 */
declare type KeysWithValue<W extends any, T extends object> = {
    [K in keyof T]: T[K] extends W ? Readonly<K> : never;
}[keyof T];
/**
 * A `PrivateKey` must start with a `_` character and then follow with
 * an alphabetic character
 */
declare type PrivateKey = `_${Alpha}${string}`;
/**
 * Keys on an object which have a `_` character as first part of the
 * name are considered private and this utility will create a union
 * of all the keys in this category.
 */
declare type PrivateKeys<T extends object> = {
    [K in keyof T]: K extends `_${string}` ? K : never;
}[keyof T];
/**
 * **PublicKeys**
 *
 * Builds a union type of all keys which are "public" where a public
 * key is any key which _does not_ start with the `_` character.
 */
declare type PublicKeys<T extends object> = {
    [K in keyof T]: K extends `_${string}` ? never : K;
}[keyof T];
declare type StringKeys<T extends object> = {
    [K in keyof T]: K extends string ? Readonly<K> : never;
}[keyof T];
/**
 * The keys of an object which _are not_ a string type
 */
declare type NonStringKeys<T extends object> = {
    [K in keyof T]: K extends string ? never : Readonly<K>;
}[keyof T];
declare type NumericKeys<T extends object> = {
    [K in keyof T]: K extends number ? Readonly<K> : never;
}[keyof T];
declare type NonNumericKeys<T extends object> = {
    [K in keyof T]: K extends number ? never : Readonly<K>;
}[keyof T];
/**
 * **RequiredProps**
 *
 * Reduces an object type to only key/value pairs where the key is required
 */
declare type RequiredProps<T extends object> = Pick<T, RequiredKeys<T>>;
/**
 * **OptionalProps**
 *
 * Reduces an object to only key/value pairs where the key is optional
 */
declare type OptionalProps<T extends object> = Pick<T, RequiredKeys<T>>;
/**
 * **WithValue**
 *
 * Reduces an object's type down to only those key/value pairs where the
 * value is of type `W`.
 * ```ts
 * const foo = { a: 1, b: "hi", c: () => "hello" }
 * // { c: () => "hello" }
 * type W = WithValue<Function, typeof foo>
 * ```
 */
declare type WithValue<W extends any, T extends object, E extends any = undefined> = undefined extends E ? Pick<T, KeysWithValue<W, T>> : Omit<Pick<T, KeysWithValue<W, T>>, KeysWithValue<E, T>>;
/**
 * Reduces an object to only the key/value pairs where the key is a
 * string.
 */
declare type WithStringKeys<T extends object> = Omit<T, NonStringKeys<T>>;
/**
 * Reduces an object to only the key/value pairs where the key is numeric.
 */
declare type WithNumericKeys<T extends object> = Omit<T, NonNumericKeys<T>>;

/**
 * **withValue**
 *
 * Reduces a dictionary object -- in both _type_ and _run-time_ structure -- to only those
 * key/value pairs which have a specified value. For instance:
 *
 * ```ts
 * const obj = { foo: 1, bar: 2, message: "hi there" };
 * // { message: "hi there" }
 * const onlyStrings = withValue(t => t.string)(obj);
 * // { foo: 1 }
 * const justOne = withValue(t => t.literal(1))(obj);
 * ```
 *
 * Note: _often useful to provide run-time type profiles with the_ `inferredType` _utility_
 */
declare function withValue<T extends any, V extends Function>(td: TypeDefinition<T, V>): <N extends Narrowable, R extends Record<string, N>>(obj: R) => ExpandRecursively<Pick<R, KeysWithValue<T, R>>>;

/**
 * **RuleDefinition**
 *
 * A rule definition is the typing for the fluent API surface that is built up
 * with the **ruleset** utility.
 */
declare type RuleDefinition<
/** the data which will be evaluated on rule execution */
T extends object, 
/** the optional props -- as a union type -- which must be defined per the rule */
H extends string = "", 
/** the key/values which will be evaluated on execution (wide type) */
E extends Partial<SameKeys<T>> = {}, 
/** the key/values which will be evaluated on execution (narrow type) */
N extends Partial<SameKeys<T>> = {}> = {
    /**
     * sets up a true/false check that a given property is defined; this
     * condition can only be applied to _optional_ properties.
     */
    has(optProp: OptionalKeys<T>): RuleDefinition<T, H & typeof optProp, E, N>;
    /**
     * Validates that a given property extends a certain value's type; comparison
     * is made assuming "wide types".
     */
    equals<K extends keyof T, V extends Pick<T, K>>(prop: K, value: V): RuleDefinition<T, H, E & Record<K, V>, N>;
    /**
     * Validates that a given property extends a certain value's type; comparison
     * is made assuming "narrow types". This is only available for props which
     * expose a
     */
    narrowlyEquals<K extends keyof T, V extends Pick<T, K>>(prop: K, value: V): RuleDefinition<T, H, E, N & Record<K, V>>;
};
/**
 * **DynamicRule**
 *
 * A dynamic rule allows type and runtime validation of a data structure
 * which extends a known `State`. It then returns the literal type `true`
 * or `false`.
 *
 * ```ts
 * type State = { id?: string; favorite: boolean; color: string };
 * // type-safe way to check whether optional prop is actually set
 * const rule: DynamicRule<State> = s => s
 *  .has("id")
 *  .equals("favorite", true)
 *  .equals("color", "red");
 * ```
 */
declare type DynamicRule<TState extends any, TResult extends true | false> = (rule: TypeCondition<any, TState>) => TResult;
/**
 * **DynamicRuleSet**
 *
 * A function which accepts the agreed `TState` generic as input and returns a discrete
 * `true` or `false` value.
 */
declare type DynamicRuleSet<TState extends any, TRules extends Record<string, TypeCondition<any, TState>>> = (rules: TRules) => true | false;

declare type RuntimeType<T> = {
    __kind: "type";
    type: T;
    is: TypeGuard<T>;
};
declare type RuntimeProp<P extends Readonly<PropertyKey>, T extends RuntimeType<any>> = {
    __kind: "prop";
    key: Readonly<P>;
    valueType: Readonly<T["type"]>;
    /**
     * Provides the _type_ to the type system when used with `typeof`.
     *
     * ```ts
     * const t = number();
     * // number
     * type T = typeof t.type;
     * ```
     *
     * **Note:** _the runtime system will get a string equivalent name:_
     * ```ts
     * const t = number();
     * // "number"
     * console.log(t.type);
     * ```
     */
    type: Record<P, T["type"]>;
    is: TypeGuard<Record<P, T["type"]>>;
};
declare type TypeOptions<T extends Partial<object> = {}> = {
    /** each type has a default type guard but you can override if you need to be more specific */
    typeGuard?: TypeGuard<T>;
} & T;

/**
 * Validates that a given type extends another and returns `true` or `false` type
 */
declare type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false;
/**
 * Validates that a given type extends another and returns `any` or `never` as a type
 */
declare type AssertExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? any : never;
declare type IfExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? VALUE : never;
/**
 * Give a type `TValue` and a comparison type `TExtends`
 */
declare type IfExtendsThen<VALUE, EXPECTED, THEN> = EXPECTED extends VALUE ? THEN : never;

/**
 * Indicates whether `T` has _all_ uppercase characters in it.
 * ```ts
 * // true
 * type T = AllCaps<"FOOBAR">;
 * // false
 * type T = AllCaps<"FooBar">;
 * // "unknown"
 * type T = AllCaps<string>;
 * ```
 */
declare type AllCaps<T extends string> = string extends T ? "unknown" : T extends Uppercase<T> ? true : false;

/**
 * **Break<T,D>**
 *
 * Takes a string `T`, and splits it into a tuple of the form `[F, R]`.
 * ```ts
 * // ["the", " long and winding road"]
 * type T1 = Break<"the long and winding road", " ">;
 * // ["there", " I was, there I was"]
 * type T2 = Break<"there I was, there I was", " ">;
 * ```
 */
declare type Break<T extends string, D extends string> = (string extends T ? [string, string] : (T extends `${infer F}${D}${infer _R}` ? (F extends `${infer _X}${D}${infer _Y}` ? never : (T extends `${F}${infer R}` ? [F, R] : never)) : [T, ""]));

/**
 * Concatenates two arrays (of literals).
 * ```ts
 * // [ "foo", "bar", "baz" ]
 * type T = ArrConcat<["foo"], ["bar", "baz"]>;
 * ```
 */
declare type ArrConcat<A extends any[], B extends any[]> = [...A, ...B];

/**
 * Type utility which takes a string `S` and replaces the substring `W` with `P`.
 * ```ts
 * const fooy = "fooy";
 * // "Foo"
 * type Foo = Replace<typeof fooy, "y", "">;
 * ```
 *
 * Note: _the first match is replaced and all subsequent matches are ignored_
 */
declare type Replace<S extends string, W extends string, P extends string> = S extends "" ? "" : W extends "" ? S : S extends `${infer F}${W}${infer E}` ? `${F}${P}${E}` : S;

/**
 * Trims off whitespace on left of string
 * ```ts
 * // "foobar "
 * type T = TrimLeft<"\n\t  foobar ">;
 * // string
 * type T = TrimLeft<string>;
 * ```
 */
declare type TrimLeft<S extends string> = string extends S ? string : S extends `${Whitespace}${infer Right}` ? TrimLeft<Right> : S;

/**
 * Provides the _left_ whitespace of a string
 * ```ts
 * // "\n\t "
 * type T = LeftWhitespace<"\n\t foobar">;
 * ```
 */
declare type LeftWhitespace<S extends string> = string extends S ? string : Replace<S, TrimLeft<S>, "">;

/**
 * Trims off whitespace on left of string
 * ```ts
 * // "\n foobar"
 * type T = TrimRight<"\n foobar \t">;
 * // string
 * type T = TrimRight<string>;
 * ```
 */
declare type TrimRight<S extends string> = string extends S ? string : S extends `${infer Right}${Whitespace}` ? TrimRight<Right> : S;

/**
 * Provides the _left_ whitespace of a string
 * ```ts
 * // "\n\t "
 * type T = LeftWhitespace<"\n\t foobar">;
 * ```
 */
declare type RightWhitespace<S extends string> = string extends S ? string : Replace<S, TrimRight<S>, "">;

/**
 * Type utility that provides the _length_ of a given string type in a way which
 * is _not_ limited to TS's recursive string length of roughly 48.
 *
 * ```ts
 * // 3
 * type Three = StringLength<"foo">;
 * ```
 */
declare type StringLength<S extends string, R extends number[] = []> = S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}${infer _Sixth}${infer _Sevebnth}${infer _Eighth}${infer _Ninth}${infer _Tenth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}${infer _Sixth}${infer _Sevebnth}${infer _Eighth}${infer _Ninth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}${infer _Sixth}${infer _Sevebnth}${infer _Eighth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}${infer _Sixth}${infer _Sevebnth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}${infer _Sixth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer _Fifth}}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer _Fourth}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer _Third}${infer Rest}` ? StringLength<Rest, [...R, 1, 1, 1]> : S extends `${infer _First}${infer _Second}${infer Rest}` ? StringLength<Rest, [...R, 1, 1]> : S extends `${infer _First}${infer Rest}` ? StringLength<Rest, [...R, 1]> : [...R]["length"];

/**
 * Trims off blank spaces, `\n` and `\t` characters from both sides of a _string literal_.
 * ```ts
 * // "foobar"
 * type T = Trim<"\n\t  foobar ">;
 * // string
 * type T = Trim<string>;
 * ```
 */
declare type Trim<S extends string> = string extends S ? string : S extends `${Whitespace}${infer Right}` ? Trim<Right> : S extends `${infer Left}${Whitespace}` ? Trim<Left> : S;

/**
 * An email address
 */
declare type Email = `${string}@${string}.${string}`;
declare type Zip5 = `${NumericString}${NumericString}${string}${NumericString}`;
declare type Zip4 = `${NumericString}${string}`;
/**
 * A relatively strong type for Zip5 or Zip5+4 zip codes
 */
declare type ZipCode = Zip5 | `${Zip5}-${Zip4}`;

/**
 * If **ALL CAPS** it converts to all lowercase; if not then it does nothing */
declare type LowerAllCaps<T extends string> = AllCaps<T> extends true ? Lowercase<T> : T;

declare type Delimiter = "_" | "-" | " ";
/** convert all delimiters to dashes */
declare type DashDelim<T extends string> = T extends `${infer Begin}${" "}${infer Rest}` ? DashDelim<`${Begin}-${Rest}`> : T extends `${infer Begin}${"_"}${infer Rest}` ? DashDelim<`${Begin}-${Rest}`> : T;
/**
 * Converts a string literal type to a **PascalCase** representation.
 * ```ts
 * // "FooBar"
 * type T = PascalCase<"fooBar">;
 * type T = PascalCase<"foo-bar">;
 * type T = PascalCase<"foo_bar">;
 * type T = PascalCase<"\n foo_bar \t">;
 * ```
 */
declare type PascalCase<S extends string> = string extends S ? string : Trim<DashDelim<LowerAllCaps<S>>> extends `${infer Begin}${Delimiter}${infer Rest}` ? PascalCase<`${Capitalize<Begin>}${Capitalize<Rest>}`> : Capitalize<Trim<LowerAllCaps<S>>>;

declare type CamelCase<S extends string> = string extends S ? string : Uncapitalize<PascalCase<S>>;

/**
 * Capitalize all words in a string
 */
declare type CapitalizeWords<S extends string> = S extends `${infer L} ${infer R}` ? `${CapitalizeWords<L>} ${CapitalizeWords<R>}` : S extends `${infer L},${infer R}` ? `${CapitalizeWords<L>},${CapitalizeWords<R>}` : S extends `${infer L}.${infer R}` ? `${CapitalizeWords<L>}.${CapitalizeWords<R>}` : Capitalize<S>;

declare type DashToSnake<T extends string> = T extends `${infer HEAD}-${infer TAIL}` ? DashToSnake<`${HEAD}_${TAIL}`> : T;

/**
 * Indicates whether `T` has uppercase characters in it.
 * ```ts
 * // true
 * type T = HasUppercase<"Foobar">;
 * // false
 * type T = HasUppercase<"foobar">;
 * // "unknown"
 * type T = HasUppercase<string>;
 * ```
 */
declare type HasUppercase<T extends string> = string extends T ? "unknown" : T extends `${string}${UpperAlpha}${string}` ? true : false;

declare type _DU<T extends string> = T extends Lowercase<T> ? T : `-${Lowercase<T>}`;
/**
 * Converts uppercase characters to a dash and then the lowercase equivalent
 * ```ts
 * // "one-two-three"
 * type T = DashUppercase<"oneTwoThree">;
 * ```
 *
 * _Intended to be used as a lower level utility; prefer `Dasherize<T>` for more full-fledged
 * dash solution_.
 */
declare type DashUppercase<T extends string> = HasUppercase<T> extends false ? T : T extends `${infer C0}${infer C1}${infer R}` ? `${_DU<C0>}${_DU<C1>}${DashUppercase<R>}` : T extends `${infer C0}${infer R}` ? `${_DU<C0>}${DashUppercase<R>}` : "";

/**
 * Converts a string literal into a _dasherized_ format while ignoring _exterior_ whitespace.
 *
 * ```ts
 * // "foo-bar"
 * type Dash = Dasherize<"foo_bar">;
 * type Dash = Dasherize<"fooBar">;
 * type Dash = Dasherize<"FooBar">;
 * // "\n  foo-bar \t"
 * type Dash = Dasherize<"\n  foo bar \t">;
 * ```
 */
declare type Dasherize<S extends string> = string extends S ? string : DashUppercase<Trim<LowerAllCaps<S>>> extends `${infer Begin}${"_" | " "}${infer Rest}` ? Dasherize<`${Lowercase<Begin>}-${Rest}`> : Lowercase<DashUppercase<Uncapitalize<Trim<LowerAllCaps<S>>>>>;

/**
 * Returns true or false value based on whether the string literal is capitalized.
 * ```ts
 * // true
 * type T2 = IsCapitalized<"One">;
 * // false
 * type T1 = IsCapitalized<"one">;
 * // "unknown"
 * const a: string = "Hi";
 * type T3 = IsCapitalized<typeof a>;
 * ```
 *
 * Note: _if the value passed in is a "string" then the result will be "unknown"_
 */
declare type IsCapitalized<T extends string> = string extends T ? "unknown" : T extends Capitalize<T> ? true : false;

/**
 * **KebabCase<T>** is an _alias_ for **Dasherize<T>**.
 * ```ts
 * // "foo-bar"
 * type Kebab = KebabCase<"foo_bar">;
 * type Kebab = KebabCase<"fooBar">;
 * type Kebab = KebabCase<"FooBar">;
 * // "\n  foo-bar \t"
 * type Kebab = KebabCase<"\n  foo bar \t">;
 * ``` */
declare type KebabCase<T extends string> = Dasherize<T>;

declare type Consonant = "b" | "c" | "d" | "f" | "g" | "h" | "j" | "k" | "l" | "m" | "n" | "p" | "q" | "r" | "s" | "t" | "v" | "w" | "x" | "z" | "y";
declare type Exceptions = "photo => photos" | "piano => pianos" | "halo => halos" | "foot => feet" | "man => men" | "woman => women" | "person => people" | "mouse => mice" | "series => series" | "sheep => sheep" | "money => monies" | "deer => deer";
declare type SingularException<T = Exceptions> = T extends `${infer SINGULAR} => ${infer PLURAL}` ? SINGULAR : never;
declare type PluralException<T extends SingularException, E extends Exceptions = Exceptions> = E extends `${T} => ${infer PLURAL}` ? PLURAL : never;
declare type SingularNoun = "s" | "sh" | "ch" | "x" | "z" | "o";
declare type F = "f" | "fe";
declare type Y = `${Consonant}y`;
declare type RemoveTrailingY<T> = T extends `${infer HEAD}y` ? HEAD : T;
/** validates that a word ends with a pluralization exception */
declare type isException<T extends string> = T extends SingularException ? T : never;
/** validates that a string literal ends in "is" */
declare type EndsIn_IS<T extends string> = T extends `${infer HEAD}is` ? T : never;
/** validates that a string literal is a singular noun */
declare type EndsInSingularNoun<T extends string> = T extends `${infer HEAD}${SingularNoun}` ? T : never;
/** validates that a string literal ends in "f" or "fe" */
declare type EndsIn_F<T extends string> = T extends `${infer HEAD}${F}` ? T : never;
/** validates that a string literal ends a consonant followed by "y" */
declare type EndsIn_Y<T extends string> = T extends `${infer HEAD}${Y}` ? T : never;
/**
 * strings which end in the letters "is" should have an "es" added to the end
 */
declare type PluralizeEndingIn_IS<T extends string> = T extends `${infer HEAD}is` ? `${HEAD}ises` : T;
/**
 * singular nouns should have "es" added to the end
 */
declare type PluralizeEndingSingularNoun<T extends string> = T extends `${infer HEAD}${SingularNoun}` ? `${T}es` : T;
/**
 * strings which end in the letters "f" or "fe" should have "ves" replace the ending
 */
declare type PluralizeEnding_F<T extends string> = T extends `${infer HEAD}${F}` ? `${HEAD}ves` : T;
/**
 * singular nouns should have "es" added to the end
 */
declare type PluralizeEndingIn_Y<T extends string> = T extends `${infer HEAD}${Y}` ? `${RemoveTrailingY<T>}ies` : T;
declare type Pluralize<T extends string> = T extends isException<T> ? PluralException<T> : T extends EndsIn_IS<T> ? PluralizeEndingIn_IS<T> : T extends EndsInSingularNoun<T> ? PluralizeEndingSingularNoun<T> : T extends EndsIn_F<T> ? PluralizeEnding_F<T> : T extends EndsIn_Y<T> ? PluralizeEndingIn_Y<T> : `${T}s`;

/** convert space to dash */
declare type SpaceToDash<T extends string> = T extends `${infer Begin}${" "}${infer Rest}` ? SpaceToDash<`${Begin}-${Rest}`> : T;
/**
 * Converts a string literal type to _snake_case_.
 * ```ts
 * // "foo_bar"
 * type T = SnakeCase<"fooBar">;
 * type T = SnakeCase<"FooBar">;
 * type T = SnakeCase<"foo-bar">;
 * type T = SnakeCase<"\n foo bar \t">;
 * ``` */
declare type SnakeCase<S extends string> = string extends S ? string : DashUppercase<Uncapitalize<SpaceToDash<Trim<LowerAllCaps<S>>>>> extends `${infer Begin}${"-"}${infer Rest}` ? SnakeCase<`${Lowercase<Begin>}_${Rest}`> : Lowercase<DashUppercase<Uncapitalize<Trim<LowerAllCaps<S>>>>>;

/**
 * **ToFluent**
 *
 * Converts the typing of a dictionary of functions into the same
 * function signatures but changes the return type to be the Fluent API.
 *
 * **Note:** this utility also allows a non-fluent API surface `X` to be included as
 * part of the API surface if this is desired.
 */
declare type ToFluent<T extends {
    [key: string]: (...args: any[]) => any;
}, X extends object = {}> = {
    [K in keyof T]: (...args: Parameters<T[K]>) => ToFluent<T, X> & X;
} & X;
/**
 * A _pure_ Fluent API which promotes an API surface where _every_ API endpoint must be a function
 * which returns the same API surface.
 *
 * To provide value, this style of Fluent API will need to perform useful _side effects_ when functions
 * on the API surface are called as this structure does not provide any means to maintain an internal state
 * which can be returned later.
 *
 * **Note:** _if you prefer a Fluent API with means to _escape_ with an internally managed state then
 * you should prefer the use of the `FluentApi` type._
 */
declare type PureFluentApi<TApi extends Record<string, (...args: any[]) => PureFluentApi<TApi, any>>, TExclude extends string = ""> = {
    [P in keyof TApi]: (...args: Parameters<TApi[P]>) => PureFluentApi<Omit<TApi, TExclude>>;
};

/**
 * A type utility which looks at a chain for functions and reduces the type
 * to the final `ReturnType` of the chain.
 *
 * ```ts
 * // number
 * type T = FinalReturn<() => (foo: string) => (bar: string) => () => number>;
 * ```
 */
declare type FinalReturn<T extends any> = T extends (...args: any[]) => any ? FinalReturn<ReturnType<T>> : T;

declare type DictFromKv<T extends readonly Readonly<{
    key: string;
    value: unknown;
}>[]> = {
    [R in T[number] as R["key"]]: R["value"];
};

/**
 * Provides a strongly typed _key_ and _value_ for a dictionary `T`
 *
 * ```ts
 * type Obj = { foo: 1, bar: "hi" };
 * // ["foo", 1 ]
 * type Foo = KeyValue<Obj, "foo">;
 * ```
 */
declare type KeyValue<T extends object, K extends keyof T> = [K & keyof T, ExpandRecursively<T[K]>];

/**
 * Type utility which takes an object type and converts to an array of KV objects:
 * ```ts
 * // [ {key: "id", value: 123 } | {key: "foo", value: "bar" } ][]
 * type Arr = KvFrom<{ id: 123, foo: "bar" }>;
 * ```
 */
declare type KvFrom<T extends object> = Array<{
    [K in keyof T]: {
        key: K;
        value: T[K];
    };
}[keyof T]>;

/**
 * **KvTuple**
 *
 * a key/value of type `T` represented as `[key, kv]`
 *
 * ```ts
 * type Obj = { foo: 1, bar: "hi" };
 * // ["foo", { foo: 1 } ]
 * type Foo = KvTuple<Obj, "foo">;
 * ```
 *
 * **Note:** _consider use of `KeyValue<T,K>` as an alternate representation_
 */
declare type KvTuple<T, K extends keyof T> = [K, Record<K, T[K]>];

/**
 * Create a union type based on a given property in an array of objects
 * ```ts
 * const data = [
 *    { id: 123, color: "blue" },
 *    { id: 456, color: "red" },
 *  ] as const;
 * // 123 | 456
 * type U = UniqueForProp<typeof data, "id">;
 * ```
 */
declare type UniqueForProp<T extends readonly Record<string, Narrowable>[], P extends string> = Readonly<Get<T[number], P>>;

declare type DictArrayFilterCallback<K extends keyof T, T extends object, R extends true | false> = (key: K, value: Pick<T, K>) => R;
/**
 * An element in a `DictArray` shaped as a two element tuple: `[key, kv]`.
 */
declare type DictArrayKv<K extends keyof T, T> = [K, Pick<T, K>];
declare type DictKvTuple<K extends string> = [K, Record<K, unknown>];
/**
 * A an array of `DictArrayKv` tuples which can be reconstructed
 * to a strongly typed dictionary object.
 * ```ts
 * const example: DictArray<{ foo: 1, bar: "hi" }> = [
 *   [ "foo", { foo: 1 }],
 *   [ "bar", { bar: "hi" }]
 * ]
 * ```
 */
declare type DictArray<T> = Array<{
    [K in keyof T]: DictArrayKv<K, T>;
}[keyof T]>;

/**
 * LastInUnion<1 | 2> = 2.
 */
declare type LastInUnion<U> = UnionToIntersection<U extends unknown ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L : never;
/**
 * UnionToTuple<1 | 2> = [1, 2].
 */
declare type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];

/**
 * Returns the _first_ key in an object.
 *
 * **Note:** key order is not guarenteed so typically this is used
 * for a key/value pair where only one key is expected
 */
declare type FirstKey<T extends object> = UnionToTuple<Keys<T>>[0];

/**
 * Utility type which operates on a dictionary and provides the **value** of the
 * `First<T>` key of the dictionary. Because dictionary's don't provide assurances
 * about key order, this is typically only used in cases where it's known there is
 * a single key on the object.
 */
declare type FirstKeyValue<T extends object> = FirstKey<T> extends keyof T ? T[FirstKey<T>] : never;

/**
 * For a two-dimensional array, returns a _union type_ which combines the first element of the interior
 * array.
 *
 * ```ts
 * const test = [ ["foo", 1], ["bar", 2] ];
 * // "foo" | "bar"
 * type F = FirstOfEach<typeof test>;
 * ```
 */
declare type FirstOfEach<T extends readonly any[][]> = T[number][0] extends T[number][number] ? T[number][0] : never;

/**
 * Converts a Tuple type into a _union_ of the tuple elements
 * ```ts
 * const arr = [1, 3, 5] as const;
 * // 1 | 3 | 5
 * type U = TupleToUnion<typeof arr>;
 * ```
 */
declare type TupleToUnion<T> = Mutable<T> extends any[] ? Mutable<T>[number] : never;

/**
 * Typescript utility which receives `T` as shape which resembles `DictArray<D>`
 * and if the type `D` can be inferred it is returned.
 * ```ts
 * // { foo: 1; bar: "hi" }
 * type Dict = FromDictArray<[["foo", { foo: 1 }], ["bar", { bar: "hi" }]]>;
 * ```
 */
declare type FromDictArray<T extends [string, Record<string, unknown>][]> = ExpandRecursively<UnionToIntersection<T[number][1]>>;

/**
 * For a two-dimensional array, returns a _union type_ which combines the first element of the interior
 * array.
 *
 * ```ts
 * // 1 | 2
 * type F = SecondOfEach<[ ["foo", 1], ["bar", 2] ]>;
 * ```
 */
declare type SecondOfEach<T extends any[][]> = T[number][1] extends T[number][number] ? T[number][1] : never;

declare function createFnWithProps<F extends Function, P extends {}>(fn: F, props: P): F & P;
/**
 * Adds a dictionary of key/value pairs to a function.
 */
declare function fnWithProps<A extends any[], R extends any, P extends {}>(fn: ((...args: A) => R), props: P): ((...args: A) => R) & P;
/**
 * Adds read-only (and narrowly typed) key/value pairs to a function
 */
declare function readonlyFnWithProps<A extends any[], R extends any, N extends Narrowable, P extends Record<keyof P, N>>(fn: ((...args: A) => R), props: P): ((...args: A) => R) & Readonly<P>;

/**
 * Provides the _keys_ of an object with the `keyof T` made explicit.
 */
declare function keys<T extends {}, W extends readonly string[]>(obj: T, ...without: W): Length<W> extends 0 ? (keyof T)[] : Exclude<keyof T, Keys<W, undefined>>[];

/**
 * **ruleSet**
 *
 * Defines a ruleset composed of _dynamic_ and _static_ boolean operators.
 *
 * - the first function call defines _dynamic_ props (_optional_)
 * - the second function call defines static values
 *
 * ```ts
 * const rs = ruleSet(
 *    r => r.state()( { maybe: r => r.extends({ foo: 1 }) })
 * )(
 *    { color: true, age: false }
 * );
 * ```
 */
declare function ruleSet<N extends Narrowable, TState extends Record<keyof TState, N>>(defn?: TState): TState | undefined;

declare const api: <N extends Narrowable, TPrivate extends Readonly<Record<any, N>>>(priv: TPrivate) => <TPublic extends object>(pub: TPublic) => () => TPublic;

/**
 * Passing in an array of strings, you are passed back a dictionary with
 * all the keys being the strings and values set to `true`.
 * ```ts
 * // { foo: true, bar: true }
 * const fooBar = arrayToKeyLookup("foo", "bar");
 * ```
 */
declare function arrayToKeyLookup<T extends readonly string[]>(...keys: T): Record<T[number], true>;

interface DefinePropertiesApi<T extends {}> {
    /**
     * Makes a property on the object **readonly** on the Javascript runtime
     */
    ro<K extends keyof T>(prop: K, errorMsg?: (p: K, v: any) => string): Omit<T, K> & Record<K, Readonly<T[K]>>;
    /**
     * Makes a property on the object **read/writeable** on the Javascript runtime;
     * this is the default so only use this where it is needed.
     */
    rw<K extends keyof T>(prop: K): Omit<T, K> & Record<K, Readonly<T[K]>>;
}
declare function defineProperties<T extends {}>(obj: T): DefinePropertiesApi<T>;

/**
 * Takes a dictionary of type `I` and converts it to a dictionary of type `O` where
 * they _keys_ used in both dictionaries are the same.
 *
 * The _transform_ function passed in must be able to recieve the full input object
 * and key, and then return expected value of `O` for the given key.
 */
declare function dictionaryTransform<I extends object, O extends SameKeys<I>>(input: I, transform: Transformer<I, O>): O;

/**
 * **entries**
 *
 * Provides an _iterable_ over the passed in dictionary object where each iteration
 * provides a tuple of `[ key, value ]` which preserve type literals.
 *
 * For example:
 * ```ts
 * const obj = { foo: 1, bar: "hi" };
 * // k type is "foo" then "bar"; v type is 1 then "hi"
 * for (const [k, v] of entries(obj)) { ... }
 * ```
 */
declare function entries<N extends Narrowable, T extends Record<string, N>, I extends KeyValue<T, keyof T>>(obj: T): {
    [Symbol.iterator](): Generator<I, void, unknown>;
};

/**
 * **mapValues**
 *
 * Maps over a dictionary, preserving the keys but allowing the values to be mutated.
 *
 * ```ts
 * const colors = { red: 4, blue: 2, green: 3 };
 * // { red: 8, blue: 4, green: 6 }
 * const twoX = mapValues(colors, v => v * 2);
 * ```
 */
declare function mapValues<N extends Narrowable, T extends Record<string, N>, V>(obj: T, valueMapper: (k: T[keyof T]) => V): { [K in keyof T]: V; };

/**
 * converts an array of strings `["a", "b", "c"]` into a more type friendly
 * dictionary of the type `{ a: true, b: true, c: true }`
 */
declare function strArrayToDict<T extends readonly string[]>(...strings: T): ExpandRecursively<Record<T[number], true>>;

/**
 * Converts a dictionary object into an array of dictionaries with `key` and `value` properties
 * ```ts
 * // [ { key: "id", value: 123 }, { key: "foo", value: "bar" } ]
 * const arr = dictToKv({ id: 123, foo: "bar" });
 * ```
 */
declare function dictToKv<N extends Narrowable, T extends Record<string, N>, U extends boolean>(obj: T, _makeTuple?: U): U extends true ? UnionToTuple<(Mutable<T> extends infer T_1 extends object ? { [K in keyof T_1]: {
    key: K;
    value: Mutable<T>[K];
}; } : never)[keyof T], LastInUnion<(Mutable<T> extends infer T_1 extends object ? { [K in keyof T_1]: {
    key: K;
    value: Mutable<T>[K];
}; } : never)[keyof T]>> : KvFrom<Mutable<T>>;

interface Array$1<T> {
    filter<U extends T>(pred: (a: T) => a is U): U[];
}
/**
 * Accepts a `DictArray` and a callback which receives each key
 * value pair.
 */
declare function filterDictArray<T extends object, C extends DictArrayFilterCallback<keyof T, T, true | false>>(dictArr: DictArray<T>, cb: C): DictArray<Omit<T, "">>;

/**
 * Build a key-value pair where both _key_ and _value_ are inferred. This
 * includes ensuring that the _key_ is a type literal not just a "string".
 *
 * > note: the value will be inferred but if you need to constrain it
 * > to a narrower type then both inferences will break and you should
 * > instead use `KV2` to get this capability.
 */
declare function kv<K extends string, N extends Narrowable, V extends Record<any, N> | boolean | number | string | null | undefined>(key: K, value: V): ExpandRecursively<Record<K, V>>;

/**
 * Converts an array of dictionaries with `key` and `value` properties to a singular dictionary.
 * ```ts
 * // { id: 123, foo: "bar" }
 * const arr = kvToDict([{ key: "id", value: 123 }, { key: "foo", value: "bar" }]);
 * ```
 *
 * Note: this is the inverse of `dictToKv()` function
 */
declare function kvToDict<K extends string, V extends Narrowable, T extends readonly Readonly<{
    key: K;
    value: V;
}>[]>(kvArr: T): DictFromKv<T>;

/**
 * Groups an array of data based on the value of a property
 * in the objects within the array.
 * ```ts
 * const data = [ {}, {}, {} ];
 *
 * ```
 *
 * @ignore not implemented
 */
declare function groupBy<T extends Record<string, Narrowable>>(_data: Readonly<T[]>): void;

declare type ExplicitFunction<P extends any[], R extends any> = (...args: P) => R;
/**
 * Takes a given function and converts it to an explicit representation
 * where the generics represent the _parameter_ and _return_ typings.
 */
declare function ExplicitFunction<T extends (...args: any[]) => any>(fn: T): ExplicitFunction<Parameters<T>, ReturnType<T>>;

/**
 * **UniqueDictionary**
 *
 * A dictionary converted by `arrayToObject()` which expects each key `S` to have a only a
 * single/unique value.
 */
declare type UniqueDictionary<S extends PropertyKey, N extends Narrowable, T extends Record<keyof T, N> & Record<S, any>> = {
    [V in T as V[S]]: V;
};
/**
 * **GeneralDictionary**
 *
 * A dictionary converted by `arrayToObject()` which expects each key `S` to have an
 * array of values.
 */
declare type GeneralDictionary<S extends PropertyKey, N extends Narrowable, T extends Record<keyof T, N> & Record<S, any>> = {
    [V in T as V[S]]: V[];
};
declare type ArrayConverter<S extends PropertyKey, U extends boolean> = 
/**
 * An `ArrayConverter` is the partial application of the `arrayToObject()`
 * utility. At this point, the configuration is setup already and all that's
 * left is to pass in an array of objects.
 */
<N extends Narrowable, T extends Record<keyof T, N> & Record<S, any>>(arr: readonly T[]) => true extends U ? UniqueDictionary<S, N, T> : GeneralDictionary<S, N, T>;
/**
 * Converts an array of objects into a dictionary by picking a property name contained
 * by all objects and using that as the key to the dictionary.
 *
 * ```ts
 * const arr = [
 *   { kind: "color", favorite: "blue", likes: 100 },
 *   { kind: "song", favorite: "some song", likes: 25 }
 * ];
 * const dict = arrayToObject("kind")(arr);
 * ```
 *
 * This will produce a dictionary with keys of `color` and `song`.
 */
declare function arrayToObject<S extends PropertyKey, U extends boolean>(prop: S, unique?: U): ArrayConverter<S, true extends U ? true : false>;

/**
 * Build a _type_ from two run-time dictionaries.
 *
 * 1. The _first_ -- which is optional -- is interpreted as a _literal_ type definition
 * 2. The _second_ dictionary is interpreted as a "wide" definition of prop types
 */
declare function defineType<N extends Narrowable, TLiteral extends Record<string, N>>(literal?: TLiteral): <TWide extends object>(wide?: TWide) => ExpandRecursively<TWide & TLiteral>;

/**
 * An identity function for any type, with the goal of preserving literal type information
 * whereever possible.
 */
declare const identity: <N extends Narrowable, T extends string | number | boolean | symbol | Record<any, N> | null | undefined>(v: T) => T;

/**
 * Takes an object as input --which has an `id` property and returns it as the same
 * run-time content but with the _type_ of the `id` property being forced to a literal type
 */
declare function idLiteral<T extends {
    id: I;
}, I extends PropertyKey>(o: T): T & {
    id: T["id"];
};
/**
 * Takes an object as input --which has an `name` property and returns it as the same
 * run-time content but with the _type_ of the `name` property being forced to a literal type
 */
declare function nameLiteral<T extends {
    name: I;
}, I extends PropertyKey>(o: T): T & {
    name: T["name"];
};
/**
 * Takes an object as input --which has an `kind` property and returns it as the same
 * run-time content but with the _type_ of the `kind` property being forced to a literal type
 */
declare function kindLiteral<T extends {
    kind: I;
}, I extends PropertyKey>(o: T): T & {
    kind: T["kind"];
};
declare function idTypeGuard<T extends {
    id: I;
}, I extends PropertyKey>(_o: T): _o is T & {
    id: I;
};
/**
 * Takes an object as input and infers the narrow literal types of the property
 * values on the object.
 *
 * > Note: this addresses this [a known TS gap](https://github.com/microsoft/TypeScript/issues/30680).
 * > Hopefully at some point this will be addressed in the language.
 */
declare function literal<N extends Narrowable, T extends Record<keyof T, N>>(obj: T): T;

declare type Filter<A> = {
    kind: "Equals";
    field: keyof A;
    val: A[keyof A];
} | {
    kind: "Greater";
    field: keyof A;
    val: A[keyof A];
} | {
    kind: "Less";
    field: keyof A;
    val: A[keyof A];
} | {
    kind: "And";
    a: Filter<A>;
    b: Filter<A>;
} | {
    kind: "Or";
    a: Filter<A>;
    b: Filter<A>;
};
declare const equals: <A, K extends keyof A>(field: K, val: A[K]) => Filter<A>;
declare const greater: <A, K extends keyof A>(field: K, val: A[K]) => Filter<A>;
declare const less: <A, K extends keyof A>(field: K, val: A[K]) => Filter<A>;
declare const and: <A>(a: Filter<A>, b: Filter<A>) => Filter<A>;
declare const or: <A>(a: Filter<A>, b: Filter<A>) => Filter<A>;

declare function Model<N extends string, _R extends {} = {}, _O extends {} = {}>(name: N): {
    required<P extends string>(_prop: P): {
        required<P_1 extends string>(_prop: P_1): any;
        optional<P_2 extends string>(_prop: P_2): any;
        done(): {
            __model__: N;
            __kind__: "model";
        };
    };
    optional<P_3 extends string>(_prop: P_3): {
        required<P_1 extends string>(_prop: P_1): any;
        optional<P_2 extends string>(_prop: P_2): any;
        done(): {
            __model__: N;
            __kind__: "model";
        };
    };
    done(): {
        __model__: N;
        __kind__: "model";
    };
};

declare type Omit$1<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
interface IConfigurator<C = {}> {
    set<V, K extends string, KV = {
        [U in K]: V;
    }>(key: K, value: V): asserts this is IConfigurator<ExpandRecursively<C & KV>>;
    remove<K extends string & keyof C>(key: K): asserts this is IConfigurator<ExpandRecursively<Omit$1<C, K>>>;
    done(): C;
}
/**
 * **Configurator**
 *
 * This function provides a configurator which uses TypeScript assertions
 * to narrow the scope of variables. Using type assertions though means we
 * can't also return values and therefore a _fluent_ API style is not possible.
 *
 * Note: this approach does require, that you explicitly use the `IConfigurator`
 * interface exported by this library. Without it you'd getting annoying TS errors
 * on every call to `set()` but adding it is simple enough:
 *
 * ```ts
 * import { Configurator, IConfigurator } from "inferred-types";
 * const config: IConfigurator = Configurator();
 * ```
 *
 * If you want to specify some guideline params which you expect to be set, you
 * can add them like so:
 *
 * ```ts
 * export type IExpected = { foo: number, bar: string };
 * const config: IConfigurator<IExpected> = Configurator<IExpected>();
 * ```
 *
 * This configuration will ensure that `foo` and `bar` will be seen as optional
 * parameters. If you set them they will stop being optional.
 */
declare function Configurator(): IConfigurator<{}>;

interface IFluentConfigurator<C> {
    /**
     * **set**
     *
     * Sets a new key/value pair to the configurator.
     *
     * @param key the key to put this new configuration item
     * @param value the value of the configuration item
     */
    set<V, K extends string, KV = {
        [U in K]: V;
    }>(key: K, value: V): IFluentConfigurator<C & KV>;
    done(): ExpandRecursively<C>;
}
/**
 * This function will return a basic _configurator_ API surface which allows
 * you to add name/value pairs to a growing dictionary of strongly typed data.
 *
 * When configuration is complete, you call the `done()` endpoint and the typed
 * configuration will be returned with the API removed.
 *
 * > **Note:** the approach taken here requires that you configure using a **fluent style**
 * exclusively. If you don't the non-fluent properties set will not show up
 * in the typing or the run-time object.
 */
declare function FluentConfigurator<I>(initial?: I): IFluentConfigurator<{}>;

export { AllCaps, Alpha, AlphaNumeric, Api, ApiFunction, ApiValue, AppendToDictionary, AppendToObject, ArrConcat, Array$1 as Array, ArrayConverter, AssertExtends, Bracket, Break, CamelCase, CapitalizeWords, ClosingBracket, Condition, Configurator, Constructor, DashToSnake, DashUppercase, Dasherize, DefinePropertiesApi, DictArray, DictArrayFilterCallback, DictArrayKv, DictChangeValue, DictFromKv, DictKvTuple, DictPartialApplication, DictPrependWithFn, DictReturnValues, DynamicRule, DynamicRuleSet, Email, EnumValues, ExpandRecursively, ExpectExtends, ExplicitFunction, ExtendsClause, ExtendsNarrowlyClause, Filter, FinalReturn, First, FirstKey, FirstKeyValue, FirstOfEach, FluentConfigurator, FluentFunction, FromDictArray, FunctionType, GeneralDictionary, Get, HasUppercase, IConfigurator, IFluentConfigurator, If, IfExtends, IfExtendsThen, Include, Includes, IsArray, IsBoolean, IsCapitalized, IsFalse, IsFunction, IsObject, IsString, IsTrue, KebabCase, KeyValue, KeyedRecord, Keys, KeysWithValue, KvFrom, KvTuple, LastInUnion, LeftWhitespace, Length, LowerAllCaps, LowerAlpha, MapTo, MaybeFalse, MaybeTrue, Model, Mutable, MutableProps, MutationFunction, MutationIdentity, Narrowable, NonAlpha, NonNumericKeys, NonStringKeys, Not, Numeric, NumericKeys, NumericString, ObjectType, Opaque, OpeningBracket, OptionalKeys, OptionalProps, Parenthesis, PascalCase, Pluralize, PrivateKey, PrivateKeys, PublicKeys, Punctuation, PureFluentApi, Replace, RequireProps, RequiredKeys, RequiredProps, Retain, RightWhitespace, RuleDefinition, RuntimeProp, RuntimeType, SameKeys, SecondOfEach, SimplifyObject, SnakeCase, SpecialCharacters, StringDelimiter, StringKeys, StringLength, ToFluent, Transformer, Trim, TrimLeft, TrimRight, TupleToUnion, Type, TypeApi, TypeCondition, TypeDefinition, TypeGuard, TypeOptions, UnionToIntersection, UnionToTuple, UniqueDictionary, UniqueForProp, UpperAlpha, ValueTuple, ValueTypeFunc, ValueTypes, Where, WhereNot, Whitespace, WithNumericKeys, WithStringKeys, WithValue, ZipCode, and, api, arrayToKeyLookup, arrayToObject, condition, createFnWithProps, createMutationFunction, defineProperties, defineType, dictToKv, dictionaryTransform, entries, equals, filterDictArray, fnWithProps, greater, groupBy, idLiteral, idTypeGuard, identity, ifTypeOf, isArray, isBoolean, isFalse, isFunction, isNull, isNumber, isObject, isString, isSymbol, isTrue, isType, isUndefined, keys, kindLiteral, kv, kvToDict, less, literal, mapValues, nameLiteral, or, randomString, readonlyFnWithProps, ruleSet, strArrayToDict, type, typeApi, uuid, valueTypes, withValue };
